################################################################################
#                    FEATURE: Storage Network System                           #
################################################################################

================================================================================
DESCRIPTION
================================================================================

Système de stockage centralisé inspiré d'Applied Energistics 2 / Refined Storage.
Permet de gérer plusieurs coffres depuis un terminal unique avec:
- Enregistrement de coffres par flood fill
- Agrégation automatique des items
- Interface de recherche et demande d'items
- Mode édition visuel avec lignes de connexion

================================================================================
ARCHITECTURE
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                              STORAGE NETWORK                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   StorageControllerBlock ────── StorageControllerBlockEntity                 │
│         │                              │                                     │
│         │ (liaison manuelle)           │ (liste coffres, items agrégés)      │
│         │                              │                                     │
│   StorageTerminalBlock ─────── StorageTerminalBlockEntity                    │
│                                        │                                     │
│                                 StorageTerminalMenu                          │
│                                        │                                     │
│                                 StorageTerminalScreen                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
FICHIERS CRÉÉS
================================================================================

BLOCKS & BLOCKENTITIES:
- common/block/storage/StorageControllerBlock.java
- common/block/storage/StorageTerminalBlock.java
- common/block/storage/StorageEditModeHandler.java
- common/block/storage/StorageEvents.java
- common/blockentity/storage/StorageControllerBlockEntity.java
- common/blockentity/storage/StorageTerminalBlockEntity.java

MENU & GUI:
- common/menu/storage/StorageTerminalMenu.java
- client/gui/screen/storage/StorageTerminalScreen.java

RÉSEAU:
- core/network/packets/StorageRequestPacket.java (client → serveur: demande items)
- core/network/packets/StorageItemsSyncPacket.java (serveur → client: sync items agrégés)

UTILITAIRES:
- core/util/StorageHelper.java (vérification conteneurs supportés)

RENDERING:
- client/renderer/block/StorageControllerRenderer.java

ASSETS:
- blockstates/storage_controller.json
- blockstates/storage_terminal.json
- models/block/storage_controller.json
- models/block/storage_terminal.json
- models/item/storage_controller.json
- models/item/storage_terminal.json

================================================================================
FONCTIONNALITÉS
================================================================================

STORAGE CONTROLLER:
- Shift+clic droit: Toggle mode édition
- En mode édition: Clic droit sur coffre = enregistrement (flood fill)
- En mode édition: Clic sur coffre enregistré = retrait
- Rayon maximum: 24 blocs
- Affiche outline rouge + lignes vertes vers coffres en mode édition
- Supporte: Chest, Trapped Chest, Barrel

STORAGE TERMINAL:
- Liaison automatique si placé en mode édition du controller
- Shift+clic: Affiche état de liaison
- Clic normal: Ouvre l'interface

INTERFACE TERMINAL:
- Barre de recherche avec filtre en temps réel
- Grille virtuelle 9x6 avec scroll
- Clic sur item: Popup de demande (---, --, -, +, ++, +++)
- 9 slots de dépôt (items → réseau automatique)
- 9 slots de pickup (demandes → joueur)
- Inventaire joueur standard
- Indicateur de requêtes en attente (badge orange)

SYSTÈME DE FILE D'ATTENTE (PENDING REQUESTS):
- Si les slots pickup sont pleins, items mis en file d'attente
- Traitement automatique toutes les 10 ticks
- Indicateur visuel: badge orange avec compteur
- Tooltip: nombre d'items et types différents en attente
- Persistance NBT (survit au restart)

SYNCHRONISATION:
- GUI ouverte: Scan chaque tick
- GUI fermée: Scan toutes les 40 ticks (2 sec)

================================================================================
REGISTRES MODIFIÉS
================================================================================

BeemancerBlocks.java:
- +STORAGE_CONTROLLER
- +STORAGE_TERMINAL

BeemancerBlockEntities.java:
- +STORAGE_CONTROLLER
- +STORAGE_TERMINAL

BeemancerItems.java:
- +STORAGE_CONTROLLER (BlockItem)
- +STORAGE_TERMINAL (BlockItem)

BeemancerMenus.java:
- +STORAGE_TERMINAL

BeemancerNetwork.java:
- +StorageRequestPacket (playToServer)
- +StorageItemsSyncPacket (playToClient)

ClientSetup.java:
- +StorageTerminalScreen
- +StorageControllerRenderer

================================================================================
MULTIBLOC STORAGE CONTROLLER (3x3x3)
================================================================================

Le Storage Controller est maintenant un multibloc 3 étages (3x3x3).
Le controller est au centre (0,0,0). Vue de côté (axe X horizontal, Y vertical):

  Étage 3 (Y+1):  honey_pipe(-1,1,0)  | controlled_hive(0,1,0) | honey_pipe(1,1,0)
  Étage 2 (Y=0):  reservoir(-1,0,0)    | CONTROLLER(0,0,0)      | reservoir(1,0,0)
                   + terminal(0,0,-1) devant le controller
  Étage 1 (Y-1):  honey_pipe(-1,-1,0) | honeyed_stone(0,-1,0)  | honey_pipe(1,-1,0)

  Toutes les autres positions du 3x3x3 = air

FORMATION:
- Clic droit sur le controller → tente la formation du multibloc
- MultiblockValidator vérifie le pattern STORAGE_CONTROLLER
- Si valide: FORMED=true sur controller + tous les blocs du pattern
- Si invalide: message d'erreur au joueur

FORMED VISUALS:
- Controller: 2 cubes de 2×2×2 pixels centrés ([6,6,6]-[8,8,8] et [8,8,8]-[10,10,10])
- Honey Pipes: colonne verticale 6×16×6 ([5,0,5]-[11,16,11]), spread ±3px vers l'extérieur
- Honeyed Stone (bas): base 16×16×16 + ailes latérales 10×10×2
- Controlled Hive (haut): cube 16×16×16 (bloc passif, le controller gère les abeilles)
- Reservoir: cube vertical 8×16×8 ([4,0,4]-[12,16,12]), spread ±3px vers l'extérieur
- Terminal: cadre 2px (barres 2px formant carré + plan portal nether au centre), z=[14,16]

SPREAD SYSTEM:
- Les colonnes pipe-reservoir-pipe sont écartées de 3px (3/16 bloc) du centre
- Le spread est calculé en world-space par StorageControllerBlockEntity
- Stocké dans HoneyPipeBlockEntity.formedSpreadX/Z et HoneyReservoirBlockEntity.formedSpreadX/Z
- Appliqué par les renderers (HoneyPipeRenderer, HoneyReservoirRenderer) via poseStack.translate()
- Le reservoir formed model est rendu par le BER (le blockstate model est vide)

DESTRUCTION:
- Casser un bloc du multibloc → onRemove() du controller reset FORMED=false sur tous
- MultiblockEvents gère aussi l'invalidation via block break events

FICHIERS AJOUTÉS (Multibloc):
- core/multiblock/MultiblockPatterns.java: +STORAGE_CONTROLLER pattern
- common/block/storage/ControlledHiveBlock.java: bloc passif FORMED + FORMED_ROTATION
- models/block/storage/storage_controller_formed.json
- models/block/storage/storage_terminal_formed.json (cadre 2px + portal)
- models/block/storage/controlled_hive.json + controlled_hive_formed.json
- models/block/pipes/honey_pipe_formed.json
- models/block/altar/honeyed_stone_formed.json (déjà existant, réutilisé)
- models/block/altar/honey_reservoir_formed.json (vidé, rendu par BER)
- models/block/altar/honey_reservoir_formed_render.json (modèle pour le BER)
- blockstates/controlled_hive.json
- textures/block/storage/controlled_hive.png

FICHIERS MODIFIÉS (Multibloc):
- StorageControllerBlock.java: +FORMED property, formation logic, onRemove
- StorageControllerBlockEntity.java: implements MultiblockController, spread calculation
- StorageTerminalBlock.java: +FORMED property
- HoneyPipeBlock.java: +FORMED property (13e boolean property)
- HoneyPipeBlockEntity.java: +formedSpreadX/Z fields, NBT, sync
- HoneyPipeRenderer.java: spread translation avant rotation
- HoneyReservoirBlockEntity.java: +formedSpreadX/Z fields, NBT, sync
- HoneyReservoirRenderer.java: formed model rendering + spread offset
- ClientSetup.java: +HoneyReservoirRenderer.FORMED_MODEL_LOC registration
- blockstates/storage_controller.json: formed=false/true variants
- blockstates/storage_terminal.json: formed=false/true variants
- blockstates/honey_pipe.json: multipart avec formed conditions
- blockstates/honey_pipe_tier2/3/4.json: idem
- blockstates/honeyed_stone.json: formed=true,layer=0 → modèle formed
- lang/en_us.json: +block.beemancer.controlled_hive
- lang/fr_fr.json: +block.beemancer.controlled_hive

================================================================================
UTILISATION
================================================================================

1. Placer un Storage Controller
2. Construire le multibloc autour (pipes, stones, reservoirs, terminal)
3. Clic droit sur le controller → formation du multibloc
4. Shift+clic droit → mode édition (outline rouge)
5. En mode édition: clic droit sur coffres → enregistrement flood fill
6. Ouvrir le terminal → voir tous les items agrégés
7. Déposer items dans slots gauche → transfert vers coffres
8. Cliquer item dans grille → popup demande → items dans slots droite

================================================================================
TRADUCTIONS
================================================================================

EN:
- block.beemancer.storage_controller: Storage Controller
- block.beemancer.storage_terminal: Storage Terminal
- container.beemancer.storage_terminal: Storage Terminal
- message.beemancer.storage_controller.edit_mode_on: Edit mode enabled...
- message.beemancer.storage_controller.edit_mode_off: Edit mode disabled
- message.beemancer.storage_controller.status: Registered: %d chests, %d terminals
- message.beemancer.storage_controller.chest_removed: Chest removed from network
- message.beemancer.storage_controller.chests_registered: %d chests registered
- message.beemancer.storage_terminal.linked: Linked to controller at (...)
- message.beemancer.storage_terminal.not_linked: Not linked to any controller
- message.beemancer.storage_terminal.auto_linked: Terminal linked to controller!
- gui.beemancer.storage_terminal.search: Search...
- gui.beemancer.storage_terminal.request: Request Items
- gui.beemancer.storage_terminal.pending_title: Pending Requests
- gui.beemancer.storage_terminal.pending_count: %d items waiting
- gui.beemancer.storage_terminal.pending_types: %d different types
- gui.beemancer.cancel: Cancel
- gui.beemancer.request: Request

FR:
- block.beemancer.storage_controller: Contrôleur de Stockage
- block.beemancer.storage_terminal: Terminal de Stockage
- (+ toutes les traductions correspondantes)

================================================================================
NOTES TECHNIQUES
================================================================================

SYNCHRONISATION CLIENT:
- StorageControllerBlockEntity et StorageTerminalBlockEntity implémentent handleUpdateTag()
- Les coffres enregistrés sont synchronisés via getUpdateTag()/handleUpdateTag()
- Les items agrégés sont envoyés via StorageItemsSyncPacket quand:
  - Un joueur ouvre le terminal (addViewer)
  - Le controller refresh les items (syncItemsToViewers)

MODE ÉDITION:
- StorageEditModeHandler est une map statique UUID → BlockPos
- Nettoyé automatiquement quand:
  - Le joueur se déconnecte (PlayerLoggedOutEvent)
  - Le serveur s'arrête (ServerStoppingEvent)
  - Le joueur s'éloigne trop (serverTick)

RENDU (StorageControllerRenderer):
- Affiche uniquement pour le joueur qui édite
- Outline rouge: autour du controller
- Lignes vertes: du controller vers chaque coffre
- Outline bleu: autour de chaque coffre enregistré
- shouldRenderOffScreen() retourne true pour les lignes longues

PROTECTION CONTRE BUGS:
- Flag isDepositing évite récursion lors du dépôt automatique
- ConcurrentModification évitée avec liste temporaire dans refreshAggregatedItems()
- Validation count dans StorageRequestPacket (clamp 1-3456)

DÉPÔT INTELLIGENT:
- depositItem() priorise les coffres contenant déjà l'item
- Phase 1: Merge dans stacks existants + slots vides du même coffre
- Phase 2: Slots vides dans n'importe quel coffre
- Évite dispersion des items identiques

PENDING REQUESTS (StorageTerminalBlockEntity):
- Queue<PendingRequest> persistante en NBT
- serverTick() traite la queue toutes les 10 ticks
- ContainerData sync le nombre d'items en attente vers client
- StorageTerminalScreen affiche badge orange si queue non vide

################################################################################
