################################################################################
#                    FEATURE: Storage Network System                           #
################################################################################

================================================================================
DESCRIPTION
================================================================================

Système de stockage centralisé inspiré d'Applied Energistics 2 / Refined Storage.
Permet de gérer plusieurs coffres depuis un terminal unique avec:
- Enregistrement de coffres par flood fill
- Agrégation automatique des items
- Interface de recherche et demande d'items
- Mode édition visuel avec lignes de connexion

================================================================================
ARCHITECTURE
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                              STORAGE NETWORK                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   StorageControllerBlock ────── StorageControllerBlockEntity                 │
│         │                              │                                     │
│         │ (liaison manuelle)           │ (liste coffres, items agrégés)      │
│         │                              │                                     │
│   StorageTerminalBlock ─────── StorageTerminalBlockEntity                    │
│                                        │                                     │
│                                 StorageTerminalMenu                          │
│                                        │                                     │
│                                 StorageTerminalScreen                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
FICHIERS CRÉÉS
================================================================================

BLOCKS & BLOCKENTITIES:
- common/block/storage/StorageControllerBlock.java
- common/block/storage/StorageTerminalBlock.java
- common/block/storage/StorageEditModeHandler.java
- common/block/storage/StorageEvents.java
- common/blockentity/storage/StorageControllerBlockEntity.java
- common/blockentity/storage/StorageTerminalBlockEntity.java

MENU & GUI:
- common/menu/storage/StorageTerminalMenu.java
- client/gui/screen/storage/StorageTerminalScreen.java

RÉSEAU:
- core/network/packets/StorageRequestPacket.java (client → serveur: demande items)
- core/network/packets/StorageItemsSyncPacket.java (serveur → client: sync items agrégés)

UTILITAIRES:
- core/util/StorageHelper.java (vérification conteneurs supportés)

RENDERING:
- client/renderer/block/StorageControllerRenderer.java

ASSETS:
- blockstates/storage_controller.json
- blockstates/storage_terminal.json
- models/block/storage_controller.json
- models/block/storage_terminal.json
- models/item/storage_controller.json
- models/item/storage_terminal.json

================================================================================
FONCTIONNALITÉS
================================================================================

STORAGE CONTROLLER:
- Shift+clic droit: Toggle mode édition
- En mode édition: Clic droit sur coffre = enregistrement (flood fill)
- En mode édition: Clic sur coffre enregistré = retrait
- Rayon maximum: 24 blocs
- Affiche outline rouge + lignes vertes vers coffres en mode édition
- Supporte: Chest, Trapped Chest, Barrel

STORAGE TERMINAL:
- Liaison automatique si placé en mode édition du controller
- Shift+clic: Affiche état de liaison
- Clic normal: Ouvre l'interface

INTERFACE TERMINAL:
- Barre de recherche avec filtre en temps réel
- Grille virtuelle 9x6 avec scroll
- Clic sur item: Popup de demande (---, --, -, +, ++, +++)
- 9 slots de dépôt (items → réseau automatique)
- 9 slots de pickup (demandes → joueur)
- Inventaire joueur standard
- Indicateur de requêtes en attente (badge orange)

SYSTEME DE DEMANDES (RequestManager):
- Interfaces et terminaux publient des InterfaceRequest (pas des DeliveryTask)
- RequestManager centralise: fusion, validation, ordonnancement, annulation
- IMPORT: coffre source → interface/terminal destination
- EXPORT: source (adjacent/terminal) → coffre destination
- Preloaded: terminal deposit pre-charge items sur la bee (skip source)
- Recall: annulation rappelle la bee au controller (vol direct retour)
- Identification par taskId (fiable meme si plusieurs bees transportent le meme item)
- Voir: Structure/feature_delivery_refactoring.txt pour details complets

SYNCHRONISATION:
- GUI ouverte: Scan chaque tick
- GUI fermée: Scan toutes les 40 ticks (2 sec)

================================================================================
REGISTRES MODIFIÉS
================================================================================

BeemancerBlocks.java:
- +STORAGE_CONTROLLER
- +STORAGE_TERMINAL

BeemancerBlockEntities.java:
- +STORAGE_CONTROLLER
- +STORAGE_TERMINAL

BeemancerItems.java:
- +STORAGE_CONTROLLER (BlockItem)
- +STORAGE_TERMINAL (BlockItem)

BeemancerMenus.java:
- +STORAGE_TERMINAL

BeemancerNetwork.java:
- +StorageRequestPacket (playToServer)
- +StorageItemsSyncPacket (playToClient)

ClientSetup.java:
- +StorageTerminalScreen
- +StorageControllerRenderer

================================================================================
MULTIBLOC STORAGE CONTROLLER (3x3x3)
================================================================================

Le Storage Controller est maintenant un multibloc 3 étages (3x3x3).
Le controller est au centre (0,0,0). Vue de côté (axe X horizontal, Y vertical):

  Étage 3 (Y+1):  controller_pipe(-1,1,0) | controlled_hive(0,1,0) | controller_pipe(1,1,0)
  Étage 2 (Y=0):  reservoir(-1,0,0)      | CONTROLLER(0,0,0)      | reservoir(1,0,0)
                   + terminal(0,0,-1) devant le controller
  Étage 1 (Y-1):  controller_pipe(-1,-1,0) | honeyed_stone(0,-1,0) | controller_pipe(1,-1,0)

  Toutes les autres positions du 3x3x3 = air

FORMATION:
- Clic droit sur le controller → tente la formation du multibloc
- MultiblockValidator vérifie le pattern STORAGE_CONTROLLER
- Si valide: FORMED=true sur controller + tous les blocs du pattern
- Si invalide: message d'erreur au joueur

FORMED VISUALS:
- Controller: 2 cubes de 2×2×2 pixels centrés ([6,6,6]-[8,8,8] et [8,8,8]-[10,10,10])
- Controller Pipes: coude (elbow) vertical+horizontal, rendu par ControllerPipeRenderer
- Honeyed Stone (bas): base 16×16×16 + ailes latérales 10×10×2
- Controlled Hive (haut): cube 16×16×16 (bloc passif, le controller gère les abeilles)
- Reservoir: cube vertical 8×16×8 ([4,0,4]-[12,16,12]), spread ±3px vers l'extérieur
- Terminal: modèle de base pour toutes les variantes (formed et non-formed identiques)

SPREAD SYSTEM:
- Les colonnes pipe-reservoir-pipe sont écartées de 3px (3/16 bloc) du centre
- Le spread est calculé en world-space par StorageControllerBlockEntity
- Stocké dans ControllerPipeBlockEntity.formedSpreadX/Z et HoneyReservoirBlockEntity.formedSpreadX/Z
- Appliqué par les renderers (ControllerPipeRenderer, HoneyReservoirRenderer) via poseStack.translate()
- Le reservoir formed model est rendu par le BER (le blockstate model est vide)

HONEY CONSUMPTION:
- Le controller consomme du miel en continu quand formé (toutes les secondes)
- Drain depuis les 2 HoneyReservoirs du multibloc (positions y=-1 et y=+1)
- Formule: (base 20 mB/s + coffres × 10 + essenceCost) × (1 - efficiency/100)
- essenceCost: pour chaque essence DROP/SPEED/FORAGING/TOLERANCE → level × 10 mB/s
- efficiency: insomnia essence → level × 10% (LESSER=10%, PERFECT=40%)
- Si plus de miel: honeyDepleted → delivery bees bloquées
- ContainerData étendu à 6 indices: +honey consumption (mB/s) + efficiency (%)

DESTRUCTION:
- Casser un bloc du multibloc → onRemove() du controller reset FORMED=false sur tous
- MultiblockEvents gère aussi l'invalidation via block break events

FICHIERS AJOUTÉS (Multibloc):
- core/multiblock/MultiblockPatterns.java: +STORAGE_CONTROLLER pattern
- common/block/storage/ControlledHiveBlock.java: bloc passif FORMED + FORMED_ROTATION
- common/block/storage/ControllerPipeBlock.java: conduit structurel FORMED
- common/blockentity/storage/ControllerPipeBlockEntity.java: rotation + spread
- client/renderer/block/ControllerPipeRenderer.java: rendu coude formed
- models/block/storage/storage_controller_formed.json
- models/block/storage/controlled_hive.json + controlled_hive_formed.json
- models/block/storage/controller_pipe.json (cube) + controller_pipe_formed.json (coude)
- models/block/pipes/honey_pipe_formed.json (legacy, non utilisé par multibloc)
- models/block/altar/honeyed_stone_formed.json (déjà existant, réutilisé)
- models/block/altar/honey_reservoir_formed.json (vidé, rendu par BER)
- models/block/altar/honey_reservoir_formed_render.json (modèle pour le BER)
- blockstates/controlled_hive.json
- blockstates/controller_pipe.json
- textures/block/storage/controlled_hive.png
- textures/block/storage/controller_pipe.png (copie honeyed_stone)
- data/beemancer/loot_table/blocks/controller_pipe.json

FICHIERS MODIFIÉS (Multibloc):
- StorageControllerBlock.java: +FORMED property, formation logic, onRemove
- StorageControllerBlockEntity.java: implements MultiblockController, spread, honey consumption
- StorageTerminalBlock.java: +FORMED property
- HoneyReservoirBlockEntity.java: +formedSpreadX/Z fields, NBT, sync
- HoneyReservoirRenderer.java: formed model rendering + spread offset
- ControllerStats.java: +getHoneyConsumption(), +getHoneyEfficiency()
- StorageControllerMenu.java: ContainerData 6 indices
- StorageControllerScreen.java: +2 stat lines (Honey, Efficiency)
- ClientSetup.java: +ControllerPipeRenderer, +HoneyReservoirRenderer.FORMED_MODEL_LOC
- blockstates/storage_controller.json: formed=false/true variants
- blockstates/storage_terminal.json: toutes variantes → modèle de base
- blockstates/honeyed_stone.json: formed=true,layer=0 → modèle formed
- lang/en_us.json: +controller_pipe, +honey_consumption, +honey_efficiency
- lang/fr_fr.json: idem

================================================================================
UTILISATION
================================================================================

1. Placer un Storage Controller
2. Construire le multibloc autour (pipes, stones, reservoirs, terminal)
3. Clic droit sur le controller → formation du multibloc
4. Shift+clic droit → mode édition (outline rouge)
5. En mode édition: clic droit sur coffres → enregistrement flood fill
6. Ouvrir le terminal → voir tous les items agrégés
7. Déposer items dans slots gauche → transfert vers coffres
8. Cliquer item dans grille → popup demande → items dans slots droite

================================================================================
TRADUCTIONS
================================================================================

EN:
- block.beemancer.storage_controller: Storage Controller
- block.beemancer.storage_terminal: Storage Terminal
- container.beemancer.storage_terminal: Storage Terminal
- message.beemancer.storage_controller.edit_mode_on: Edit mode enabled...
- message.beemancer.storage_controller.edit_mode_off: Edit mode disabled
- message.beemancer.storage_controller.status: Registered: %d chests, %d terminals
- message.beemancer.storage_controller.chest_removed: Chest removed from network
- message.beemancer.storage_controller.chests_registered: %d chests registered
- message.beemancer.storage_terminal.linked: Linked to controller at (...)
- message.beemancer.storage_terminal.not_linked: Not linked to any controller
- message.beemancer.storage_terminal.auto_linked: Terminal linked to controller!
- gui.beemancer.storage_terminal.search: Search...
- gui.beemancer.storage_terminal.request: Request Items
- gui.beemancer.storage_terminal.pending_title: Pending Requests
- gui.beemancer.storage_terminal.pending_count: %d items waiting
- gui.beemancer.storage_terminal.pending_types: %d different types
- gui.beemancer.cancel: Cancel
- gui.beemancer.request: Request

FR:
- block.beemancer.storage_controller: Contrôleur de Stockage
- block.beemancer.storage_terminal: Terminal de Stockage
- (+ toutes les traductions correspondantes)

================================================================================
NOTES TECHNIQUES
================================================================================

SYNCHRONISATION CLIENT:
- StorageControllerBlockEntity et StorageTerminalBlockEntity implémentent handleUpdateTag()
- Les coffres enregistrés sont synchronisés via getUpdateTag()/handleUpdateTag()
- Les items agrégés sont envoyés via StorageItemsSyncPacket quand:
  - Un joueur ouvre le terminal (addViewer)
  - Le controller refresh les items (syncItemsToViewers)

MODE ÉDITION:
- StorageEditModeHandler est une map statique UUID → BlockPos
- Nettoyé automatiquement quand:
  - Le joueur se déconnecte (PlayerLoggedOutEvent)
  - Le serveur s'arrête (ServerStoppingEvent)
  - Le joueur s'éloigne trop (serverTick)

RENDU (StorageControllerRenderer):
- Affiche uniquement pour le joueur qui édite
- Outline rouge: autour du controller
- Lignes vertes: du controller vers chaque coffre
- Outline bleu: autour de chaque coffre enregistré
- shouldRenderOffScreen() retourne true pour les lignes longues

PROTECTION CONTRE BUGS:
- Flag isDepositing évite récursion lors du dépôt automatique
- ConcurrentModification évitée avec liste temporaire dans refreshAggregatedItems()
- Validation count dans StorageRequestPacket (clamp 1-3456)

DÉPÔT INTELLIGENT:
- depositItem() priorise les coffres contenant déjà l'item
- Phase 1: Merge dans stacks existants + slots vides du même coffre
- Phase 2: Slots vides dans n'importe quel coffre
- Évite dispersion des items identiques

SYSTEME DE LIVRAISON (refactored):
- RequestManager attache au StorageControllerBlockEntity
- Interfaces/terminaux publient InterfaceRequest via publishRequest()
- RequestManager convertit PENDING → DeliveryTask via processRequests()
- StorageDeliveryManager spawn les bees, gere queue + recall
- Flux unifie 6 phases: FLY_TO_SOURCE → WAIT → FLY_TO_CONTROLLER → FLY_TO_DEST → WAIT → FLY_HOME
- Preloaded: bee spawn avec items, saute source (terminal deposit)
- Recall: annulation → bee vole directement retour controller
- Details complets: Structure/feature_delivery_refactoring.txt

################################################################################
